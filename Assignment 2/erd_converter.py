from erd import *
from table import *

# This function converts an ERD object into a Database object
# The Database object should correspond to a fully correct implementation
# of the ERD, including both data structure and constraints, such that the
# CREATE TABLE statements generated by the Database object will populate an
# empty MySQL database to exactly implement the conceptual design communicated
# by the ERD.
#
# @TODO: Implement me!
def is_missing(dependencies, current_dependency):
    for dependency in dependencies:
        if dependency not in current_dependency:
            return True
    return False

def is_primary_key(relationship):
    if len(relationship.primary_key) == 0:
        return True
    return False

def multiplicity(entity_sets, relationship):
    connections = []
    for connection in entity_sets.connections:
        if connection[0] == relationship:
            connections.append(connection[1])
    return connections[0]

def convert_to_table(erd):
    dependents, relations = {}, {}
    converted_table, excluded_table = [], set()
    MANY, ONE = Multiplicity.MANY, Multiplicity.ONE
    
    for entity in erd.entity_sets:
        if len(entity.parents) > 0:
            for parent in entity.parents:
                dependents[entity.name] = [(parent, "isA")]
        else:
            dependents[entity.name] = []

    for relationship in erd.relationships:
        entities = []
        for entity in erd.entity_sets:
            for connection in entity.connections:
                if relationship.name in connection[0]:
                    entities.append(entity)

        counter = 0
        for entity in entities:
            if multiplicity(entity, relationship.name) == MANY:
                counter += 1

        if counter == 1 and is_primary_key(relationship):
            many_to_one, one_to_many = [], []
            for entity in entities:
                entity_multiplicity = multiplicity(entity, relationship.name)
                if entity_multiplicity == MANY:
                    many_to_one = [entity.name][0]
                elif entity_multiplicity == ONE:
                    one_to_many.append(entity.name)
                
            for entity in one_to_many:
                dependents[many_to_one].append((entity, relationship.name))
            excluded_table = excluded_table.union({relationship.name})
        elif len(entities) == 1:
            for entity in erd.entity_sets:
                if relationship.name in entity.supporting_relations:
                    initial_entity = [entity][0]
                    dependents[initial_entity.name].append((entities[0].name, relationship.name))
            excluded_table = excluded_table.union({relationship.name})
        
        temp_entity = []
        for entity in entities:
            entity_multiplicity = multiplicity(entity, relationship.name)
            temp_entity.append((entity.name, entity_multiplicity))
            relations[relationship.name] = temp_entity

    entities = list(erd.entity_sets)
    for i in range(len(entities)):
        for entity in entities:
            temp_dependents, temp_converted_table = [], []
            for dependency in dependents[entity.name]:
               temp_dependents.append(dependency[0])
            for table in converted_table:
                temp_converted_table.append(table.name)

            if not is_missing(temp_dependents, temp_converted_table):
                individial_entity = entity
                entities.remove(entity)
                break

        attributes, foreign_keys, primary_keys = set(individial_entity.attributes), set(), set(individial_entity.primary_key)
        
        for dependency in dependents[individial_entity.name]:
            temp_keys = []
            for table in converted_table:
                if table.name == dependency[0]:
                    temp_keys.append(table)
                    keys = temp_keys[0].primary_key

            attributes = attributes.union(keys)

            keys = tuple(keys)
            key_dependency_pair = [(keys, dependency[0], keys)]
            foreign_keys = foreign_keys.union(set(key_dependency_pair))
          
            if dependency[1] == "isA" or dependency[1] in individial_entity.supporting_relations:
                primary_keys = primary_keys.union(keys)
            elif dependency[1] in individial_entity.supporting_relations:
                temp_relationship = []
                for relationship in erd.relationships:
                    if relationship.name == dependency[1]:
                        temp_relationship.append(relationship)
                attributes = attributes.union(set(temp_relationship[0].attributes))           

        new_table = Table(individial_entity.name, attributes, primary_keys, foreign_keys)
        converted_table += [new_table]

    for relationship in erd.relationships:
        if relationship.name not in excluded_table:
            for relationship in [relationship]:
                attributes, primary_keys, foreign_keys = set(relationship.attributes), set(relationship.primary_key), set()
                for member in relations[relationship.name]:
                    for table in converted_table:
                        if table.name in member[0]:
                            for table in [table]:
                                temp_member = []
                                for member in relations[relationship.name]:
                                    if member[0] == table.name:
                                        temp_member.append(member)
                                        
                                if temp_member[0][1] != ONE:
                                    primary_keys = primary_keys.union(table.primary_key)
                                    
                                attributes = attributes.union(table.primary_key)

                                table_key = tuple(table.primary_key)
                                key_name_pair = [(table_key, table.name, table_key)]
                                foreign_keys = foreign_keys.union(set(key_name_pair))
                converted_table += [Table(relationship.name, attributes, primary_keys, foreign_keys)]
 
    return Database(converted_table)
